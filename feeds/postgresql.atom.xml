<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Alexey Chernyshov's blog - PostgreSQL</title><link href="https://alexey-n-chernyshov.github.io/blog/" rel="alternate"></link><link href="https://alexey-n-chernyshov.github.io/blog/feeds/postgresql.atom.xml" rel="self"></link><id>https://alexey-n-chernyshov.github.io/blog/</id><updated>2017-12-27T12:00:00+03:00</updated><entry><title>Physical recovery with pg_filedump</title><link href="https://alexey-n-chernyshov.github.io/blog/physical-recovery-with-pg_filedump.html" rel="alternate"></link><published>2017-12-27T12:00:00+03:00</published><updated>2017-12-27T12:00:00+03:00</updated><author><name>Alexey Chernyshov</name></author><id>tag:alexey-n-chernyshov.github.io,2017-12-27:/blog/physical-recovery-with-pg_filedump.html</id><summary type="html">&lt;p&gt;New features of pg_filedump for recovery&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Physical recovery with pg_filedump&lt;/h1&gt;
&lt;p&gt;If you can’t start your PostgreSQL database and want to recover latest data from database heap files or want to recover just deleted or updated values, &lt;code&gt;pg_filedump&lt;/code&gt; will help you.&lt;/p&gt;
&lt;h2&gt;About&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;pg_filedump&lt;/code&gt; is a utility to dump the contents of the heap/index/control files. Some time ago it was enhanced to be suitable for the physical data recovery from the database heap files. Also recently there was added an ability to recover the TOAST values and skip the deleted values to &lt;code&gt;pg_filedump&lt;/code&gt;. Thus, &lt;code&gt;pg_filedump&lt;/code&gt; is a full-featured recovery tool now.&lt;/p&gt;
&lt;h3&gt;Behind the scene&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.postgresql.org/docs/current/static/storage-file-layout.html"&gt;Tables in PostgreSQL&lt;/a&gt; are stored in the heap files divided into segments which are gigabyte-sized by default. The segments consist of pages (8kb by default) which store the data row by row. If an attribute is too large, TOAST mechanism takes place. Simply put, it compresses, slices the data into chunks and stores them in an external table. When a transaction deletes some data, actually, it is not deleted from the file immediately and can be restored. That’s &lt;a href="http://momjian.us/main/writings/pgsql/mvcc.pdf"&gt;how MVCC works&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Usage&lt;/h2&gt;
&lt;p&gt;Let’s see the facilities of &lt;code&gt;pg_filedump&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Install&lt;/h3&gt;
&lt;p&gt;It’s easy to build.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone git://git.postgresql.org/git/pg_filedump.git
cd pg_filedump
make
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Example&lt;/h3&gt;
&lt;p&gt;Let’s create a test table and populate it with data from psql. I added about a couple KB of text with &lt;code&gt;pg_read_file&lt;/code&gt; to demonstrate the TOAST’ed data. Checkpoint at the end flushes the data files to the disk:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# create table my_table(i int, t timestamp, content text);
# insert into my_table values (1, now(), &amp;#39;some text&amp;#39;);
# insert into my_table values (2, now(), ‘to be deleted’);
# insert into my_table values (3, now(), pg_read_file(&amp;#39;file_to_delete.txt&amp;#39;));
# insert into my_table values (4, now(), pg_read_file(&amp;#39;some_file.txt&amp;#39;));
# checkpoint;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can get the relation id in an easy way as (we’ll consider further the more general way to know the heap file name):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;select relfilenode from pg_class where relname = &amp;#39;my_table&amp;#39;;
 relfilenode 
-------------
       16408
(1 row)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can find it by the name.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;find /path/to/db/ -type f | grep 16408
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And dump the file. We should pass types of the table with &lt;code&gt;-D&lt;/code&gt; option.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;./pg_filedump -D int,timestamp,text /path/to/database/base/12445/16408
*******************************************************************
* PostgreSQL File/Block Formatted Dump Utility - Version 10.0
*
* File: /var/lib/postgresql/9.6/main/base/12445/16408
* Options used: -D int,timestamp,text 
*
* Dump created on: Mon Dec 25 18:38:02 2017
*******************************************************************

Block    0 ********************************************************
&amp;lt;Header&amp;gt; -----
 Block Offset: 0x00000000         Offsets: Lower      40 (0x0028)
 Block: Size 8192  Version    4            Upper    7952 (0x1f10)
 LSN:  logid      0 recoff 0x0157e770      Special  8192 (0x2000)
 Items:    4                      Free Space: 7912
 Checksum: 0x0000  Prune XID: 0x0000027d  Flags: 0x0000 ()
 Length (including item array): 40

&amp;lt;Data&amp;gt; ------ 
 Item   1 -- Length:   50  Offset: 8136 (0x1fc8)  Flags: NORMAL
COPY: 1 2017-12-25 18:31:03.547059  some text
 Item   2 -- Length:   54  Offset: 8080 (0x1f90)  Flags: NORMAL
COPY: 2 2017-12-25 18:31:21.451178  to be deleted
 Item   3 -- Length:   58  Offset: 8016 (0x1f50)  Flags: NORMAL
COPY: 3 2017-12-25 18:32:00.895268  (TOASTED)
 Item   4 -- Length:   58  Offset: 7952 (0x1f10)  Flags: NORMAL
COPY: 4 2017-12-25 18:32:04.745484  (TOASTED)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The data we are interested in is after COPY. Option -o skips the deleted data and -t option outputs the TOAST’ed values.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;./pg_filedump -o -D int,timestamp,text /var/lib/postgresql/9.6/main/base/12445/16408 | grep COPY

COPY: 1 2017-12-25 18:31:03.547059  some text
COPY: 4 2017-12-25 18:32:04.745484      very large string
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;But what if we don’t know the segment number or the database schema? For example, we cannot start PostgreSQL instance. The PostgreSQL stores all the data about tables in the table named &lt;code&gt;pg_class&lt;/code&gt; with relfilenode id 1259. Thus, we can get the segment number by the name of our table. Here &lt;code&gt;~&lt;/code&gt; in &lt;code&gt;-D&lt;/code&gt; argument means the rest of the row we do not consider.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;./pg_filedump -D name,oid,oid,oid,oid,oid,oid,~ /path/to/database/1259 | grep COPY | grep my_table
COPY: my_table  2200    16410   0   10  0   16408
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Where the last number is our segment number 16408. We can obtain the schema from the table name &lt;code&gt;pg_attribute&lt;/code&gt; with relfilenode 1249 as well. The third column is an oid of the attribute type.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;./pg_filedump -ot -D oid,name,oid,int,smallint,~ /var/lib/postgresql/9.6/main/base/12445/1249 | grep 16408
COPY: 16408 i   23  -1  4
COPY: 16408 t   1114    -1  8
COPY: 16408 content 25  -1  -1
COPY: 16408 ctid    27  0   6
COPY: 16408 xmin    28  0   4
COPY: 16408 cmin    29  0   4
COPY: 16408 xmax    28  0   4
COPY: 16408 cmax    29  0   4
COPY: 16408 tableoid    26  0   4
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The next step is to get the types by the oids which are 23, 25 and 1114.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;./pg_filedump -i -D name,~ /path/to/database/1247 | grep -A5 -E &amp;#39;OID: (23|25|1114)&amp;#39;
  XMIN: 1  XMAX: 0  CID|XVAC: 0  OID: 23
  Block Id: 0  linp Index: 8   Attributes: 30   Size: 32
  infomask: 0x0909 (HASNULL|HASOID|XMIN_COMMITTED|XMAX_INVALID) 
  t_bits: [0]: 0xff [1]: 0xff [2]: 0xff [3]: 0x07 

COPY: int4
--
  XMIN: 1  XMAX: 0  CID|XVAC: 0  OID: 25
  Block Id: 0  linp Index: 10   Attributes: 30   Size: 32
  infomask: 0x0909 (HASNULL|HASOID|XMIN_COMMITTED|XMAX_INVALID) 
  t_bits: [0]: 0xff [1]: 0xff [2]: 0xff [3]: 0x07 

COPY: text
--
  XMIN: 1  XMAX: 0  CID|XVAC: 0  OID: 1114
  Block Id: 1  linp Index: 39   Attributes: 30   Size: 32
  infomask: 0x0909 (HASNULL|HASOID|XMIN_COMMITTED|XMAX_INVALID) 
  t_bits: [0]: 0xff [1]: 0xff [2]: 0xff [3]: 0x07 

COPY: timestamp
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here we know the relfilenode of the table we are looking for and the schema and can easily dump the content of the table.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;./pg_filedump -D int,timestamp,text /path/to/database/base/16408
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Credits&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The initial idea and review by Teodor Sigaev.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://git.postgresql.org/gitweb/?p=pg_filedump.git;a=commit;h=5c5ba458fa154183d11d43218adf1504873728fd"&gt;Partial recovery (-D option)&lt;/a&gt;, &lt;a href="https://git.postgresql.org/gitweb/?p=pg_filedump.git;a=commit;h=5c5ba458fa154183d11d43218adf1504873728fd"&gt;support decoding of the catalog tables&lt;/a&gt;, and review by Aleksandr Alekseev.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://git.postgresql.org/gitweb/?p=pg_filedump.git;a=commit;h=e27dc124f4e1ee317e7ba9e4481bd3067f1b7c71"&gt;Omitting the deleted tuples (-o)&lt;/a&gt; and &lt;a href="https://git.postgresql.org/gitweb/?p=pg_filedump.git;a=commit;h=4738ab7111f25fc3d23ca61a3075b302f5213be2"&gt;support for the TOAST'ed values&lt;/a&gt; by Alexey Chernyshov.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://wiki.postgresql.org/wiki/Pg_filedump"&gt;Wiki page on pg_filedump&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.dbi-services.com/displaying-the-contents-of-a-postgresql-data-file-with-pg_filedump/"&gt;More on pg_filedump. Find it interesting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://afiskon.github.io/pgday2017-talk.html"&gt;PG Day'17 talk&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="PostgreSQL"></category></entry><entry><title>pgindent</title><link href="https://alexey-n-chernyshov.github.io/blog/pgindent.html" rel="alternate"></link><published>2017-06-30T11:00:00+03:00</published><updated>2017-07-21T16:00:00+03:00</updated><author><name>Alexey Chernyshov</name></author><id>tag:alexey-n-chernyshov.github.io,2017-06-30:/blog/pgindent.html</id><summary type="html">&lt;p&gt;New pgindent tool&lt;/p&gt;</summary><content type="html">&lt;p&gt;The PostgreSQL code has really confusing indents. For the help for programmers,
there is a tool named pgindent located at &lt;code&gt;src/tools/pgindent&lt;/code&gt;. Earlier it was
written in C and has had a set of dependencies, the installation was tedious.
Now, it is rewritten in Perl and downloads all dependencies itself. The only
requirement is &lt;code&gt;pg_config&lt;/code&gt; on &lt;code&gt;PATH&lt;/code&gt;, to run it in such way use &lt;code&gt;--build&lt;/code&gt;
option. The tool clones git repo &lt;code&gt;pg_bsd_indent&lt;/code&gt;, downloads typedefs, indents
and then deletes repo. If the previous run was not successful, the repository
will stay in the &lt;code&gt;src/tools/pgindent/pg_bsd_indent&lt;/code&gt; and will cause an error for
git clone command, just remove it. The other point it generates files for
typedefs, do not forget to delete them before commit. To indent single file
run:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;src/tools/pgindent/pgindent --build filename
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;To indent all files in current directory and subdirectories:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;src/tools/pgindent/pgindent --build
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;There are also pgperltidy for Perl.&lt;/p&gt;</content><category term="PostgreSQL"></category></entry></feed>